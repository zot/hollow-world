# üì® P2P Message Protocol Specification

**JSON message format for Hollow World P2P communication**

*Based on [`p2p.md`](p2p.md)*

## üìã Message Structure

All P2P messages are JSON objects with the following base structure:

```json
{
  "method": "string",
  ...additional properties
}
```

- `method` (required): String indicating which method to execute
- Additional properties are method-specific

### Request-Response Messages

Some messages follow a **request-response pattern** where a request expects a corresponding response.

**Request-Response Characteristics:**
- **Request messages** include a `messageId` field for correlation
- **Response messages** echo back the `messageId` from the request
- **messageId format**: `{messagePrefix}{messageCount}`
  - Generated by the sender using a random prefix + sequential counter
  - Ensures unique identification for matching responses to requests
- **Handler mechanism**: Sender can register a callback that executes when the response arrives

**Currently Supported Request-Response Pairs:**
- `ping` (request) ‚Üí `pong` (response)

## üîß Message Methods

### `requestFriend`

Sent when a player adds another player as a friend by peer ID. This message serves both as an initial friend request and as an acceptance response.

```json
{
  "method": "requestFriend",
  "playerName": "string"
}
```

**Fields:**
- `playerName` (optional): The requesting player's display name
  - **Not guaranteed to be unique** - multiple players can have the same name
  - **May be empty/missing** - UI handlers must use fallback (e.g., `Peer ${peerId.substring(0, 8)}`)
  - Used for display purposes only; peer ID is the unique identifier

**Stubborn Delivery (Automatic Retry):**
This message uses the ack handler pattern to track delivery status:
1. When sent, friend is marked `pending: 'unsent'` and peer ID added to ephemeral `unsentFriends` set
2. Ack handler changes to `pending: 'pending'` on successful delivery and removes from set
3. If peer is offline, remains 'unsent' and stays in set
4. **On app initialization**: System rebuilds `unsentFriends` set from all friends with `pending: 'unsent'`
5. **When peer connects** (while user is online): Automatically resends if still 'unsent' (friend data fetched from FriendsManager - single source of truth)
6. Works across app restarts - set is rebuilt from persisted friend data

**Behavior on sending peer (Player A):**
1. Player A adds Player B to their friends list with `pending: 'unsent'`
2. Message sent to Player B's peer ID with ack handler
3. **If acked**: Changes to `pending: 'pending'`
4. **If not acked** (peer offline): Stays 'unsent', auto-retries when peer comes online
5. Player A's friend entry remains in pending state until mutual acceptance

**Behavior on receiving peer (Player B):**
1. Check if Player A is in Player B's ban list:
   - **If banned**: Silently ignore the message (no event created, no response)
   - Prevents spam from unwanted peers
2. Check if Player A is already in Player B's friends list:
   - **If already has pending status**: Clear the `pending` field (mutual friend request = automatic acceptance)
     - Create a "friend accepted" event to notify Player B
     - Refresh friend UI if Friends view is visible (update all states: collapsed, expanded, etc.)
   - **If not in list**: Create a friend request event
3. If event created:
   - Event displays in event notification modal
   - Event shows the requesting player's name and peer ID
   - Event has Accept, Ignore, and Ban buttons
4. If Accept clicked:
   - Add Player A to Player B's friends list with `pending: 'unsent'`
   - Send `requestFriend` back to Player A (mutual acceptance) with ack handler
   - **If acked**:
     - Clear `pending` field (friendship established - Player A received acceptance and already wanted friendship)
     - Refresh friend UI if Friends view is visible to show friend is now fully connected
   - **If not acked** (Player A offline):
     - Friend stays `pending: 'unsent'`, will auto-retry when Player A comes online
   - Remove event
5. If Ignore clicked:
   - Remove event without adding friend or sending message
   - Player A's friend entry remains in pending state (they can remove it manually)
   - Player A's system will keep retrying delivery when Player B comes online
6. If Ban clicked:
   - Add Player A to ban list (persisted)
   - Remove event without adding friend or sending message
   - Future friend requests from Player A will be silently ignored
   - Player A's system will keep retrying (but all attempts will be silently ignored)

**Purpose:** Initiates friend requests and mutually accepts them. When both peers send `requestFriend` to each other, both clear their `pending` flags and the friendship is established.

**Note on Declining:** There is no `declineFriend` message. If a user doesn't want to accept a friend request, they simply ignore it. The requester will see their friend as `pending` and can remove it manually if desired. This keeps the protocol friendly and non-confrontational.

### Friend Presence Indicators

**Overview:** Friends have a non-persisted `presence` boolean field indicating whether they are currently online.

**Presence Tracking:**
- **Non-persisted**: The `presence` field is NOT saved to storage (ephemeral, runtime-only)
- **Initialization**: On app startup, after subscribing to the pubsub topic and monitoring peer join/leave:
  1. Get initial peer list from `listPeers()`
  2. For each friend, check if their peer ID is in the connected peers list
  3. Set `presence: true` if found, `presence: false` otherwise
- **Real-time Updates**: When peers join/leave the topic:
  - **Peer joins**: If peer ID matches a friend, set `presence: true` and refresh friend in all visible contexts
  - **Peer leaves**: If peer ID matches a friend, set `presence: false` and refresh friend in all visible contexts

**UI Display:**
- Presence indicator shown in ALL contexts where friends are visible:
  - Friends view (friend cards)
  - Character editor (world sharing)
  - Any other friend-related UI
- Visual indicator: "üü¢" (online) or "‚ö´" (offline)
- Indicator placement: Next to friend's name

**View Refresh on Presence Change:**
- When a friend's presence changes, refresh the friend display in all visible contexts
- Preserve UI state (collapsed/expanded) during refresh
- Uses the same `refreshFriendsViewCallback` mechanism as friend acceptance

---

### `ping`

Sent to test peer connectivity and measure round-trip latency. This is a **request message** in the request-response pattern.

```json
{
  "method": "ping",
  "timestamp": number,
  "messageId": "string"
}
```

**Fields:**
- `timestamp`: Unix timestamp (milliseconds) when the ping was sent
- `messageId`: Unique identifier for matching the pong response (format: `{messagePrefix}{messageCount}`)

**Behavior on receiving peer:**
1. Immediately respond with a `pong` message
2. Include the received `timestamp` and `messageId` in the pong response
3. Log the ping receipt (optional, for debugging)

**Purpose:** Test that peer addresses are resolved and P2P connection is working. Used for connectivity verification and latency measurement.

---

### `pong`

Sent in response to a `ping` message. This is a **response message** in the request-response pattern.

```json
{
  "method": "pong",
  "timestamp": number,
  "messageId": "string"
}
```

**Fields:**
- `timestamp`: The original timestamp from the ping message (echo back)
- `messageId`: The messageId from the ping request (echo back for correlation)

**Behavior on receiving peer:**
1. Calculate round-trip time: `Date.now() - timestamp`
2. Look up handler in `pendingResponses` using the `messageId`
3. If handler found: execute handler and remove from `pendingResponses`
4. If handler not found: log warning (unexpected or duplicate response)
5. Log successful connectivity (optional, for debugging)
6. Mark peer as reachable

**Purpose:** Confirms bidirectional P2P connectivity and allows latency calculation. Triggers registered handler for request-response completion.

---

## üîí Security Notes

- All messages are transmitted over encrypted libp2p streams (Noise protocol)
- Peer authentication is handled by the libp2p security layer
- Message signing can be enabled for pubsub messages via GossipSub configuration
- Validate all incoming message fields before processing
- Reject malformed or invalid messages

## üìù Implementation Requirements

1. **Validation**: Each message handler MUST validate all required fields
2. **Type Safety**: Use TypeScript interfaces for all message types
3. **Error Handling**: Gracefully handle invalid or malformed messages
4. **Logging**: Log all received messages for debugging
5. **Immutability**: Message structures are immutable - do not modify without updating this spec
