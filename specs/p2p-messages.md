# üì® P2P Message Protocol Specification

**JSON message format for Hollow World P2P communication**

*Based on [`p2p.md`](p2p.md)*

## üìã Message Structure

All P2P messages are JSON objects with the following base structure:

```json
{
  "method": "string",
  ...additional properties
}
```

- `method` (required): String indicating which method to execute
- Additional properties are method-specific

### Request-Response Messages

Some messages follow a **request-response pattern** where a request expects a corresponding response.

**Request-Response Characteristics:**
- **Request messages** include a `messageId` field for correlation
- **Response messages** echo back the `messageId` from the request
- **messageId format**: `{messagePrefix}{messageCount}`
  - Generated by the sender using a random prefix + sequential counter
  - Ensures unique identification for matching responses to requests
- **Handler mechanism**: Sender can register a callback that executes when the response arrives

**Currently Supported Request-Response Pairs:**
- `ping` (request) ‚Üí `pong` (response)

## üîß Message Methods

## üìã Invitation Format

Before sending a `requestFriend` message, the requester receives a **base64-encoded invitation string** containing:

```json
{
  "inviteCode": "string",
  "peerId": "string",
  "addresses": {
    "external": ["ip_address", ...],  // Optional: External/public IP addresses
    "internal": ["ip_address", ...]   // Optional: Internal/LAN IP addresses (excluding localhost)
  }
}
```

**Fields:**
- `inviteCode`: Random 8-character alphanumeric code
- `peerId`: LibP2P peer ID of the inviter
- `addresses`: IP addresses for direct connection (manual address exchange)
  - `external`: Public/external IP addresses detected via STUN
  - `internal`: Local network IP addresses (192.168.x.x, 10.x.x.x, etc.) excluding localhost

**Usage:**
1. Inviter calls `createInvitation(friendName, friendId?)` which detects IPs and returns base64 string
2. Inviter shares base64 string out-of-band (copy/paste, QR code, etc.)
3. Requester calls `sendRequestFriend(base64String)` which:
   - Decodes the invitation
   - Compares external IPs to determine routing (internal vs external addresses)
   - Attempts direct connection using addresses before falling back to DHT/relay

**Connection Routing Logic:**
- If both peers share the same external IP (same LAN/NAT), use internal addresses
- Otherwise, use external addresses for direct connection
- If direct connection fails, fall back to DHT discovery and circuit relay

---

### `requestFriend`

Sent to the peer ID specified in an invitation to request adding them as a friend.

```json
{
  "method": "requestFriend",
  "inviteCode": "string"
}
```

**Fields:**
- `inviteCode`: The invitation code extracted from the base64-encoded invitation string

**Behavior on receiving peer:**
1. Check `activeInvitations` object for `inviteCode` entry
2. If entry has a `friendId`, verify it matches the message sender's peer ID
3. If valid: Create a friend request event
   - Event displays in event notification modal
   - Event view shows Accept and Ignore buttons
   - Accept button: Adds the friend to the friend list and removes event
   - Ignore button: Removes event without adding friend
4. If invalid: Log invalid friend request

**Purpose:** Initiates a friend request using the invite code system. The requester first decodes the base64 invitation to extract the peer ID and addresses, then sends this message to establish the friend request.

---

### `approveFriendRequest`

Sent in response to a friend request to approve or decline it.

```json
{
  "method": "approveFriendRequest",
  "peerId": "string",
  "nickname": "string",
  "approved": boolean
}
```

**Fields:**
- `peerId`: The approver's libp2p peer ID
- `nickname`: Display name of the approver
- `approved`: `true` to approve, `false` to deny

**Behavior on receiving peer:**
- If `approved` is `true`:
  - Add an entry for the peer to the friends map using the provided `nickname`
  - Remove the peer from quarantine if present
  - Add a "friend approved" event to the event list
    - Event view has a "View Friend" button
    - Button removes the event and navigates to settings page with friend selected (`#friend=PEERID`)
- If `approved` is `false`:
  - Log the declined request

**Purpose:** Responds to a friend request. When approved, establishes a bidirectional friend relationship and notifies the requester.

---

### `ping`

Sent to test peer connectivity and measure round-trip latency. This is a **request message** in the request-response pattern.

```json
{
  "method": "ping",
  "timestamp": number,
  "messageId": "string"
}
```

**Fields:**
- `timestamp`: Unix timestamp (milliseconds) when the ping was sent
- `messageId`: Unique identifier for matching the pong response (format: `{messagePrefix}{messageCount}`)

**Behavior on receiving peer:**
1. Immediately respond with a `pong` message
2. Include the received `timestamp` and `messageId` in the pong response
3. Log the ping receipt (optional, for debugging)

**Purpose:** Test that peer addresses are resolved and P2P connection is working. Used for connectivity verification and latency measurement.

---

### `pong`

Sent in response to a `ping` message. This is a **response message** in the request-response pattern.

```json
{
  "method": "pong",
  "timestamp": number,
  "messageId": "string"
}
```

**Fields:**
- `timestamp`: The original timestamp from the ping message (echo back)
- `messageId`: The messageId from the ping request (echo back for correlation)

**Behavior on receiving peer:**
1. Calculate round-trip time: `Date.now() - timestamp`
2. Look up handler in `pendingResponses` using the `messageId`
3. If handler found: execute handler and remove from `pendingResponses`
4. If handler not found: log warning (unexpected or duplicate response)
5. Log successful connectivity (optional, for debugging)
6. Mark peer as reachable

**Purpose:** Confirms bidirectional P2P connectivity and allows latency calculation. Triggers registered handler for request-response completion.

---

## üîí Security Notes

- All messages are transmitted over encrypted libp2p streams (Noise protocol)
- Peer authentication is handled by the libp2p security layer
- Message signing can be enabled for pubsub messages via GossipSub configuration
- Validate all incoming message fields before processing
- Reject malformed or invalid messages

## üìù Implementation Requirements

1. **Validation**: Each message handler MUST validate all required fields
2. **Type Safety**: Use TypeScript interfaces for all message types
3. **Error Handling**: Gracefully handle invalid or malformed messages
4. **Logging**: Log all received messages for debugging
5. **Immutability**: Message structures are immutable - do not modify without updating this spec
